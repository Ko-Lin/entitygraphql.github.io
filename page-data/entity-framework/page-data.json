{"componentChunkName":"component---src-templates-docs-js","path":"/entity-framework","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"87bd47a2-dee7-5fca-8fbb-f7bb2edfdeb4","title":"Entity Framework","slug":"/entity-framework"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Entity Framework\",\n  \"metaTitle\": \"Working with Entity Framework - EntityGraphQL\",\n  \"metaDescription\": \"Working with Entity Framework & GraphQL\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"EntityGraphQL is built to work extremely well with EntityFramework. To see how let's first look at what EntityGraphQL does with GraphQL queries.\"), mdx(\"h1\", null, \"Examples\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DemoContext\"), \" and the schema we created from the Getting Started section, lets look at the sample queries.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"query {\\n    movie(id: 11) {\\n        id name\\n    }\\n}\\n\")), mdx(\"p\", null, \"EntityGraphQL parses the GQL document into an internal representation and uses the schema we built to construct a .NET expression. It will look like this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var expression = (DemoContext ctx, AnonymousType<> args) =>\\n    ctx.Movies\\n        .Where(movie => movie.Id == args.id)\\n        .Select(movie => new {\\n            id = movie.Id,\\n            name = movie.Name\\n        })\\n        .FirstOrDefault();\\n\")), mdx(\"p\", null, \"You can see all we need to execute this expression is an instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DemoContext\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args\"), \" object which is built by EntityGraphQL on parsing of the GQL document. Given those things EntityGraphQL can do similar to this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var results = expression.Compile().DynamicInvoke(demoContextInstance, argInstance);\\n\")), mdx(\"p\", null, \"Now if your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DemoContext\"), \" is built on top of Entity Framework \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" when EntityGraphQL executes the expression EF will take over and do its thing!\"), mdx(\"p\", null, \"Namely note that EntityGraphQL only selects the fields asked for and therefore EF will also only return the fields we ask for. Meaning no over fetching to the DB either. If your table had many fields and some large ones, they are not selected from the DB unless the API user asks for those fields.\"), mdx(\"p\", null, \"Let's look at a more complicated example.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n    movies {\\n        id\\n        name\\n        director {\\n            name\\n        }\\n        writers {\\n            name\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"Will result in the following expression.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var expression = (DemoContext ctx) =>\\n    ctx.Movies\\n        .Select(movie => new {\\n            id = movie.Id,\\n            name = movie.Name,\\n            director = new {\\n                name = movie.Director.Name\\n            },\\n            writers = movie.Writers.Select(writer => new {\\n                name = writer.Name\\n            })\\n        });\\n\")), mdx(\"p\", null, \"Again, EF will take over and fetch your data for you.\"), mdx(\"p\", null, \"You'll note that EntityGraphQL doesn't care what the context is. It could be a object graph 100% held in memory. What does matter is that when the expression executes and resolves something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"movie.Writers.Select()\"), \" that the object has the expected data loaded, or like EF can resolve the data.\"), mdx(\"p\", null, \"Other ORMs built on top of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LinqProvider\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" should also work although have not been tested.\"), mdx(\"h1\", null, \"How EntityGraphQL handles WithService() with EF\"), mdx(\"p\", null, \"Since using EntityGraphQL against an Entity Framework Core \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DbContext\"), \" is supported we handle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" in a way that will work with EF Core (and possibly other IQueryable based ORMs) which allow EF to build an optimal SQL statement. EF core 3.1+ will throw an error by default if it can't translate an expression to SQL. It can't translate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" to SQL. To support EF 3.1+ performing optimal queries (and selecting only the fields you request) EntityGraphQL builds the expressions in 2 parts.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This can be disabled by setting the argument \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"executeServiceFieldsSeparately\"), \" when executing to \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"false\"), \". For example if your core context is an in memory object.\")), mdx(\"p\", null, \"If you encounter any issues when using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" on fields and EF Core 3.1+ please raise an issue.\"), mdx(\"p\", null, \"Example of how EntityGraphQL handles \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \", which can help inform how you build/use other services.\"), mdx(\"p\", null, \"Given the following GQL\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"{\\n  people { age manager { name } }\\n}\\n\")), mdx(\"p\", null, \"Where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"age\"), \" is defined with a service as\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.Type<Person>().AddField(\\\"age\\\",\\n    (person) => WithService((AgeService ager) => ager.GetAge(person.Birthday)),\\n    \\\"Persons age\\\");\\n\")), mdx(\"p\", null, \"EntityGraphQL will build an expression query that first selects everything from the base context (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DemoContext\"), \" in this case) that EF can execute. Then another expression query that runs on top of that result which includes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \" fields. This means EF can optimise your query and return all the data requested (and nothing more) and in memory we then merge that with data from your services.\"), mdx(\"p\", null, \"An example in C# of what this ends up looking like.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var dbResultFunc = (DbContext context) => context.People.Select(p => new {\\n    Birthday = p.Birthday, // extracted from the WithService call as it is needed in the in-memory resolution\\n    manager = new {\\n        name = p.Manager.Name\\n    }\\n})\\n.ToList(); // EF will fetch data\\nvar dbResult = dbResultFunc(dbContext);\\n\\n// note dbResult is an anonymous type known at runtime\\nvar resultsFunc = (AnonType dbResult, AgeService ager) => dbResult.Select(p => {\\n    age = ager.GetAge(p.Birthday)), // passing in data we selected just for this\\n    manager = p.manager // simple selection from the previous result\\n})\\n.ToList();\\nvar results = resultsFunc(dbResult, ager);\\n\")), mdx(\"p\", null, \"This allows EF Core to make it's optimizations and prevent over fetching of data when using EntityGraphQL against an EF DbContext.\"), mdx(\"h1\", null, \"Limitations with using \", mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"GetService()\"), \" & EF\"), mdx(\"p\", null, \"If you are using the above functionality where the query will be completed in 2 parts, below are the current limitations to think about when building fields using services.\"), mdx(\"p\", null, \"Do not traverse through a relation in your field expression that uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WithService()\"), \".\"), mdx(\"p\", null, \"An example of what will not work.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.UpdateType<Floor>(type => {\\n  type.AddField(\\\"floorUrl\\\",\\n    f => WithService((IFloorUrlService s) => s.BuildFloorPlanUrl(f.SomeRelation.FirstOrDefault().Id)),\\n    \\\"Current floor url\\\", \\\"String\\\");\\n});\\n\")), mdx(\"p\", null, \"This will trigger the expression we build for EF to select \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"floor.SomeRelation\"), \" which errors in EF because of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dotnet/efcore/issues/23205\"\n  }, \"this issue\"), \" (or related).\"), mdx(\"p\", null, \"For now you can modify you field to only select fields on the context and update the service to load anything it needs to return the correct data. Remember you services can access the DB context or anything else it needs via DI as well.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.UpdateType<Floor>(type => {\\n  type.AddField(\\\"floorUrl\\\",\\n    f => WithService((IFloorPlanUrlService s) => s.BuildFloorUrlFromFloorId(f.Id)),\\n    \\\"Current floor url\\\", \\\"String\\\");\\n});\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#examples","title":"Examples"},{"url":"#how-entitygraphql-handles-withservice-with-ef","title":"How EntityGraphQL handles WithService() with EF"},{"url":"#limitations-with-using-getservice--ef","title":"Limitations with using GetService() & EF"}]},"parent":{"relativePath":"entity-framework.md"},"frontmatter":{"metaTitle":"Working with Entity Framework - EntityGraphQL","metaDescription":"Working with Entity Framework & GraphQL"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/integration","title":"Integration"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/paging","title":"Paging"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/schema-creation/06-naming","title":"Note on Naming"}}}]}},"pageContext":{"id":"87bd47a2-dee7-5fca-8fbb-f7bb2edfdeb4"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}