{"componentChunkName":"component---src-templates-docs-js","path":"/schema-creation/01-mutations","result":{"data":{"site":{"siteMetadata":{"title":"Entity GraphQL Docs","docsLocation":"https://github.com/lukemurray/EntityGraphQL/tree/master/docs/content"}},"mdx":{"fields":{"id":"b5a36ba9-8a27-527e-abee-446e397891b9","title":"Mutations","slug":"/schema-creation/01-mutations"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mutations\",\n  \"metaTitle\": \"Adding mutations to your schema - EntityGraphQL\",\n  \"metaDescription\": \"Add mutations to your GraphQL schema\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Lets add some mutations. Mutations are GraphQLs way all allowing modifications to data.\"), mdx(\"p\", null, \"Read more about GraphQL mutations \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphql.org/learn/queries/#mutations\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"In EntityGraphQL mutations are just .NET methods with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[GraphQLMutation]\"), \" attribute that receive arguments, perform work (update data etc.) and return data. You can contain these in a mutation class where related mutations can be located near each other.\"), mdx(\"h1\", null, \"Adding a Mutation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"public class PeopleMutations\\n{\\n    [GraphQLMutation(\\\"Add a new person to the system)]\\n    public Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args)\\n    {\\n        var person = new Person\\n        {\\n            FirstName = args.FirstName,\\n            LastName = args.LastName,\\n        };\\n        db.People.Add(person);\\n        db.SaveChanges();\\n\\n        return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n    }\\n}\\n\\n[MutationArguments]\\npublic class AddPersonArgs\\n{\\n    public string FirstName { get; set; }\\n    public string LastName { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Now we can add it to the schema.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"schema.AddMutationFrom(new PeopleMutations());\\n\")), mdx(\"p\", null, \"Now we can add people!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id\\n        fullName\\n    }\\n}\\n\")), mdx(\"p\", null, \"Above we use our mutation to add a person and select their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fullName\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" in the result.\"), mdx(\"h1\", null, \"Why Use \", mdx(\"inlineCode\", {\n    parentName: \"h1\"\n  }, \"Expression\"), \" Return Type\"), mdx(\"p\", null, \"Note the return signature above and the result we return is an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<>>\"), \" that selects the person we just modified.\"), mdx(\"p\", null, \"Just like in queries, if the mutation field returns an object type, you can ask for nested fields. This can be useful for fetching the new state of an object after an update.\"), mdx(\"p\", null, \"One API user may ask for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id\\n    }\\n}\\n\")), mdx(\"p\", null, \"And another might want more\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"mutation {\\n    addNewPerson(firstName: \\\"Bill\\\", lastName: \\\"Murray\\\") {\\n        id firstName fullName\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you don't know which fields an API user will request, you therefore don't know what data to load into memory and return in that object. As EntityGraphQL will execute the field selection against the returned object.\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Expression<Func<>>\"), \" as a return type allows EntityGraphQL to build an expression across the whole schema graph. And example of the expression result built for the above mutation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(DemoContext ctx) => ctx.People\\n    .Where(p => p.Id == <id_from_variable>)\\n    .Select(p => new {\\n        id = p.Id,\\n        firstName = p.FirstName,\\n        fullName = $\\\"{p.FirstName} {p.LastName}\\\"\\n    })\\n    .First()\\n\")), mdx(\"p\", null, \"This means we have access to the full schema graph from the core context of the schema and if you are using an ORM like Entity Framework it will load the requested data for you.\"), mdx(\"h1\", null, \"Dependencies Injection & Services\"), mdx(\"p\", null, \"You likely want to access some services in your mutations. EntityGraphQL supports dependency injection. When you execute a query you can pass in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \". Here is an example with ASP.NET.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"var results = _schemaProvider.ExecuteQuery(query, demoContext, HttpContext.RequestServices, null);\\n\")), mdx(\"p\", null, \"EntityGraphQL will use that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceProvider\"), \" to resolve any services when calling your mutation method. All you need to do is make sure the service is registered and include it in the method signature of the mutation.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// in Startup.cs\\nservices.AddSingleton<IDemoService, DemoService>();\\n\\n// your mutation method\\n[GraphQLMutation(\\\"Add a new person to the system)]\\npublic Expression<Func<DemoContext, Person>> AddNewPerson(DemoContext db, AddPersonArgs args, IDemoService demoService)\\n{\\n    // do something cool with demoService\\n\\n    return (ctx) => ctx.People.First(p => p.Id == person.Id);\\n}\\n\")), mdx(\"p\", null, \"Later we'll learn how to access services within fields of the query schema.\"), mdx(\"h1\", null, \"Validation\"), mdx(\"p\", null, \"You can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.ComponentModel.DataAnnotations.Required\"), \" attribute to add validaiton to your mutation arguments. Example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c#\"\n  }, \"public class ActorArgs\\n{\\n  [Required(AllowEmptyStrings = false, ErrorMessage = \\\"Actor Name is required\\\")]\\n  public string Name { get; set; }\\n  public int Age { get; set; }\\n}\\n\")), mdx(\"p\", null, \"If you do not supply a non empty string as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" argument for the mutation you'll get an error message.\"), mdx(\"p\", null, \"If your model validation fails from a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RequiredAttribute\"), \" you mutation method \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"will not be called\"), \".\"), mdx(\"p\", null, \"You can also add multiple error messages instead of throwing an exception on the first error using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLValidator\"), \" service.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class MovieMutations\\n{\\n  [GraphQLMutation]\\n  public Expression<Func<MyDbContext, Movie>> AddActor(MyDbContext db, ActorArgs args, GraphQLValidator validator)\\n  {\\n    if (string.IsNullOrEmpty(args.Name))\\n      validator.AddError(\\\"Name argument is required\\\");\\n    if (args.age <= 0)\\n      validator.AddError(\\\"Age argument must be positive\\\");\\n\\n    if (validator.HasErrors)\\n      return null;\\n\\n    // do your magic here. e.g. with EF or other business logic\\n    var movie = db.Movies.First(m => m.Id == args.Id);\\n    var actor = new Person { Name = args.Name, ... };\\n    movie.Actors.Add(actor);\\n    db.SaveChanges();\\n    return ctx => ctx.Movies.First(m => m.Id == movie.Id);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Of course if you opt to throw an exception it will be caught and included in the error results.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#adding-a-mutation","title":"Adding a Mutation"},{"url":"#why-use-expression-return-type","title":"Why Use Expression Return Type"},{"url":"#dependencies-injection--services","title":"Dependencies Injection & Services"},{"url":"#validation","title":"Validation"}]},"parent":{"relativePath":"schema-creation/01-mutations.md"},"frontmatter":{"metaTitle":"Adding mutations to your schema - EntityGraphQL","metaDescription":"Add mutations to your GraphQL schema"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/authorization","title":"Authorization"}}},{"node":{"fields":{"slug":"/","title":"Entity GraphQL"}}},{"node":{"fields":{"slug":"/entity-framework","title":"Entity Framework"}}},{"node":{"fields":{"slug":"/getting-started","title":"Getting Started"}}},{"node":{"fields":{"slug":"/integration","title":"Integration"}}},{"node":{"fields":{"slug":"/schema-creation/01-mutations","title":"Mutations"}}},{"node":{"fields":{"slug":"/paging","title":"Paging"}}},{"node":{"fields":{"slug":"/schema-creation","title":"Schema Creation"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/schema-creation/02-fields","title":"Field Arguments"}}},{"node":{"fields":{"slug":"/schema-creation/04-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/schema-creation/05-other-data-sources","title":"Other Data Sources"}}},{"node":{"fields":{"slug":"/schema-creation/03-types","title":"Other Types"}}},{"node":{"fields":{"slug":"/schema-creation/06-naming","title":"Note on Naming"}}}]}},"pageContext":{"id":"b5a36ba9-8a27-527e-abee-446e397891b9"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}